---
title: Batch Operations
tags:
  - required
---

Batch operations are a way to bundle multiple API requests into a single HTTP request.
This can be useful when you need to make multiple requests to the same API, or to multiple APIs,
and you want to reduce the number of round trips between the client and the server.

## Summary
```http
POST /batch HTTP/1.1
Authorization: Bearer your_auth_token
Content-Type: multipart/mixed; boundary=batch_boundary
Content-Length: total_content_length

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

GET /namespace/v1/resource_name/{id}

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

PUT /namespace/v1/resource_name
Content-Type: application/json
Content-Length: part_content_length
If-Match: "etag"

{
  ... body boundary
}
--batch_boundary--
```

### Requirements

- Much like REST, batch requests do not guarantee a specific order of execution.
- Batch requests do not provide a method for referencing between child requests.
- Batch requests should be route, version, and microservice agnostic.
- Batch requests should not be tightly coupled to microservice releases.
- We do not want to have a ‘spotty’ batch implementation which works for some resources, but not others.
- We want batch requests to be properly load-balanced, instead of overloading a single microservice with a large batch of requests that appear to only be one.

For the above reasons, we will provide a single batch API endpoint, implemented at the gateway, whose responsibility is receiving, dispatching, collecting, and returning batch operations.

### Building a Batch Request

```http
POST /batch HTTP/1.1
Authorization: Bearer <csp_access_token>
Content-Type: multipart/mixed; boundary=batch_boundary
Content-Length: total_content_length
```

The header which differentiates a batch request from a regular request is the Content-Type. By using the `multipart/mixed` content type, we are able to use this one HTTP request to bundle multiple HTTP requests, very similar to attaching files to an email. These are separated by the boundary string.

### Adding a Request to the Batch

```http
--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

# The raw http request is here. For example, this is a GET request.
GET /namespace/v1/resource_name/{id}

--batch_boundary-- # The trailing dashes indicates end of document
```

To add an HTTP request to a batch request, we surround it with the boundary string and include the following two headers:

- `Content-Type: application/http` - which indicates that the content is an HTTP request.
- `Content-ID: <opaque_random_string>` - a unique identifier that allows a client to correlate a request with the eventual response.

### Parsing a Batch Response

```http
HTTP 1.1/200 OK
Content-Type: multipart/mixed; boundary=batch_boundary
Content-Length: total_content_length
```

A batch response, assuming it was properly authorized, should always return `200`. This indicates that the batch request was properly received and processed, however, it makes no assumptions about the individual requests within the batch.

### Extracting the Responses from a Batch

```http
--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string_1>

# The raw response MIME type is here.
HTTP 1.1/200 Ok
Content-Type: application/json

{ payload... }

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string_2>

# The raw response MIME type is here. For example, this is an error.
HTTP 1.1/404 Not Found

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string_2>

# The raw response MIME type is here. For example, this is an error.
HTTP 1.1/404 Not Found

--batch_boundary--
```

The response can be split using the `--boundary` value, and individual content blocks can be extracted and parsed. In the case where a `Content-ID` was provided in the original request, the response body for this request will carry the same `Content-ID`.

### Resource Timeouts

Any gateway that implements this needs to - by necessity - implement a request timeout for sub-requests. In the case where a child request does not return within the timeout, the HTTP response should include a `504 Gateway Timeout` boundary for the affected request, however, the overall batch request should return with a `200`.

In alignment with existing research, the timeout for any sub-resource will be 1 second. If a request is canceled for this reason, the batch handler needs to inform the microservice that a request is canceled.

### Request and Response Size Limits

While the HTTP Specification does not restrict requests and responses to specific sizes, our toolchain often imposes restrictions. The lowest of these is our API Gateway with a restriction of 10MB. Rather than exhaust this payload, we are imposing the following limits on our batch requests:

- No more than 50 requests may be batched at a time.
- The total collated batch request cannot exceed 5MB in size.
- The total collated batch response cannot exceed 5MB in size.
- A single batched request cannot exceed 100KB in size.
- A response for a single batched request cannot exceed 100KB in size.

### Error Cases

If the aggregate request exceeds the 5MB limit, or if more than 50 requests are made in a single batch, the batch endpoint should handle no requests, and immediately return with `413 Entity Too Large`.

```http
HTTP 1.1/413 Entity Too Large
```

All batched requests that do not exceed 100KB should be honored, while any batched requests that are too large should - in their own response - return a `413 Entity Too Large`.

```http
HTTP 1.1/200 Ok
Content-Type: multipart/mixed; boundary=batch_boundary
Content-Length: total_content_length

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

HTTP 1.1/200 OK
--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

HTTP 1.1/413 Entity Too Large
--batch_boundary--
```

### Authorization

Authorization for a batch request is handled at the top level. The batch handler is required to validate the authorization, and then pass that authorization on to every child request that is made. It will not make assumptions about roles or permissions.

### Private vs. Public

The above specification is required for all public APIs. There are, however, private use cases that wish to avoid routing every batch request through a splitting proxy to avoid unnecessary latency. For these use cases, we recommend HTTP be dropped altogether, and a more performance-oriented protocol such as gRPC be used.

### Tracing

In order to maintain traceability in batch requests, every child request should be treated as a distinct unit of the originating request forest, using the following guidelines:

- The parent HTTP request should receive a trace ID as per the [API Request Tracing](https://cloudcoreo.atlassian.net/wiki/spaces/PD/pages/1259634749/API+Request+Tracing) specification.
- Any child request that does not have a trace ID, should be given one derived from the parent.
- If a child request already has its own trace ID, this should be honored and treated as an independent request.
- As with any microservice, the `parent_id` of the trace ID should be uniquely generated in order to identify its path through the proxy.

```http
POST /namespace/v1/resource HTTP/1.1
Authorization: Bearer your_auth_token
Content-Type: multipart/mixed; boundary=batch_boundary
Content-Length: total_content_length
traceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-00

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

GET /namespace/v1/resource_name/{id}
// A new traceparent will be generated from the batch request traceparent
// with a new parent_id

--batch_boundary
Content-Type: application/http
Content-ID: <opaque_random_string>

PUT /namespace/v1/resource_name
Content-Type: application/json
Content-Length: part_content_length
// This traceparent will be passed through as is.
traceparent: 00-0af7651916cd43dd8448eb211111111-23456789098765-00
If-Match: "etag"

{
  ... body boundary
}
--batch_boundary--
```
